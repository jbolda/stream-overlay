/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState, useEffect } from "react";
import { useOperation } from "@effection/react";
import { useGLTF } from "@react-three/drei";
import { InstancedRigidBodies } from "@react-three/rapier";

import cup from "../../assets/gltf/items/cup-transformed.glb";

export default function Model({
  position = [0, 0, 0],
  count = 10,
  twitchStream,
  ...props
}) {
  const api = useRef();
  const [drop, toggleDrop] = useState(true);
  const channelAlert = useAlert(
    twitchStream.filter(
      (alert) => alert.event === "onReward" && alert.args[1] === "Drop Cups"
    ),
    toggleDrop
  );

  // We can set the initial positions, and rotations, and scales, of
  // the instances by providing an array equal to the instance count
  const positions = Array.from({ length: count }, (_, index) => [
    0,
    40 + 50 * Math.random(),
    index * 3 - 5,
  ]);

  useEffect(() => {
    if (drop) {
      api.current.forEach((mesh, index) => {
        // mesh.sleep();
        mesh.setRotation({ x: -1.47, y: 0, z: 1.47 });
        mesh.setLinvel({ x: 0, y: 0, z: 0 });
        mesh.setAngvel({ x: 0, y: 0, z: 0 });
        mesh.setTranslation({
          x: 0,
          y: 40 + 50 * Math.random(),
          z: index * 3 - 5,
        });
      });
      toggleDrop(false);
    }
  }, [drop]);

  const { nodes, materials } = useGLTF(cup);
  return (
    <group {...props} dispose={null} scale={[0.42, 0.42, 0.52]}>
      <InstancedRigidBodies positions={positions} colliders="hull" ref={api}>
        <instancedMesh
          castShadow
          receiveShadow
          args={[nodes.Cup.geometry, materials.Material, count]}
        />
      </InstancedRigidBodies>
    </group>
  );
}

useGLTF.preload(cup);

function useAlert(stream, toggleDrop) {
  let [state, setState] = useState({ message: "" });
  useOperation(
    stream.forEach(function* (value) {
      console.log(value);
      setState(value);
      toggleDrop(true);
    }),
    [stream]
  );
  return state;
}

// <instancedMesh castShadow args={[null, null, count]}>
//   <mesh
//     castShadow
//     receiveShadow
//     geometry={nodes.Cup.geometry}
//     material={materials.Material}
//     position={[0, 1, 0]}
//   />
/* <instancedMesh
            castShadow
            args={[nodes.Cup.geometry, materials.Material, count]}
            position={[0, 1, 0]}
          /> */
// <mesh
//   castShadow
//   receiveShadow
//   geometry={nodes.Handle.geometry}
//   material={materials.Material}
//   position={[1.03, 1.19, 0]}
//   rotation={[-1.47, 0, 0]}
//   scale={[0.42, 0.42, 0.52]}
// />
/* <instancedMesh
            castShadow
            args={[nodes.Handle.geometry, materials.Material, count]}
            position={[1.03, 1.19, 0]}
            rotation={[-1.47, 0, 0]}
            scale={[0.42, 0.42, 0.52]}
          /> */
// </instancedMesh>
