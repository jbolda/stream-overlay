/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useMemo, useState, useEffect } from "react";
import { useFrame, useThree } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import wFlange from "../../assets/gltf/structure/w-flange.gltf";
import {
  Physics,
  RigidBody,
  Debug,
  InstancedRigidBodies,
  CuboidCollider,
} from "@react-three/rapier";
import {
  Matrix4,
  Vector3,
  Euler,
  Quaternion,
  Object3D,
  MathUtils,
} from "three";

export default function Model({ position = [0, 0, 0], count = 10, ...props }) {
  const group = useRef();
  const api = useRef();
  const tempObject = useMemo(() => new Object3D(), []);
  const mouse = useThree((state) => state.mouse);
  const viewport = useThree((state) => state.viewport);
  const [drop, toggleDrop] = useState(true);

  // We can set the initial positions, and rotations, and scales, of
  // the instances by providing an array equal to the instance count
  const positions = Array.from({ length: count }, (_, index) => [
    0,
    40 + 50 * Math.random(),
    index * 3 - 5,
  ]);

  // setInterval(() => {
  //   console.log("boop");
  //   Object.values(meshRef.current).forEach((matrix, index) => {
  //     // dummy.matrix.set(0, 40 + 50 * Math.random(), 0);
  //     // dummy.updateMatrix();
  //     meshRef.current.setMatrixAt(index, matrix);
  //   });

  //   meshRef.current.instanceMatrix.needsUpdate = true;
  // }, 1000);
  // useEffect(() => {
  // }, []);

  // useFrame((state) => {
  // const time = state.clock.getElapsedTime();
  // let mouseX = (mouse.x * viewport.width) / 2;
  // let mouseY = (mouse.y * viewport.height) / 2;
  // let mousePos = new Vector3(mouseX, mouseY, 0);
  // let particlePos = new Vector3(x, y, z);
  // let dist = mousePos.distanceTo(particlePos);

  // if (dist < 0.5) {
  //   x += 1;
  //   y += 1;
  // }
  // meshRef.current.rotation.x = Math.sin(time / 4);
  // meshRef.current.rotation.y = Math.sin(time / 2);
  // meshRef.current.position.y = 10;
  // console.log(time);
  // for (let i = 0; i < count; i++) {
  // console.log(i);
  // tempObject.position.set(0, time, i * 3 - 5); // 40 + 50 * Math.random(), i * 3 - 5);
  // tempObject.updateMatrix();
  // meshRef.current.isMoving();
  // meshRef.current.setMatrixAt(i, tempObject.matrix);
  // }
  // meshRef.current.instanceMatrix.needsUpdate = true;
  // });

  // useFrame((state) => {
  //   const time = state.clock.getElapsedTime();
  //   const t = Math.floor(time) % 15;
  //   console.log(t);
  //   // api.current.forEach((mesh, index) => {
  //   //   mesh.applyImpulse({ x: 0, y: time, z: 0 });
  //   // });
  //   if (t === 0) {
  //     api.current.forEach((mesh, index) => {
  //       // mesh.sleep();
  //       mesh.setRotation({ x: 0, y: 0, z: 0 });
  //       mesh.setLinvel({ x: 0, y: 0, z: 0 });
  //       mesh.setAngvel({ x: 0, y: 0, z: 0 });
  //       mesh.setTranslation({
  //         x: 0,
  //         y: 40 + 50 * Math.random(),
  //         z: index * 3 - 5,
  //       });
  //     });
  //   }
  // });

  setInterval(() => {
    toggleDrop(true);
  }, 15000);

  useEffect(() => {
    if (drop) {
      api.current.forEach((mesh, index) => {
        // mesh.sleep();
        mesh.setRotation({ x: 0, y: 0, z: 0 });
        mesh.setLinvel({ x: 0, y: 0, z: 0 });
        mesh.setAngvel({ x: 0, y: 0, z: 0 });
        mesh.setTranslation({
          x: 0,
          y: 40 + 50 * Math.random(),
          z: index * 3 - 5,
        });
      });
      toggleDrop(false);
    }
  }, [drop]);

  const { nodes, materials } = useGLTF(wFlange);
  return (
    <group ref={group} {...props} dispose={null}>
      <InstancedRigidBodies positions={positions} colliders="hull" ref={api}>
        <instancedMesh
          castShadow
          args={[nodes.Plane.geometry, materials["Material.001"], count]}
        />
      </InstancedRigidBodies>
    </group>
  );
}

useGLTF.preload(wFlange);
